#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPTS_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
# shellcheck disable=SC1091
source "${SCRIPTS_DIR}/lib/common.sh"
# shellcheck disable=SC1091
source "${SCRIPTS_DIR}/recipes/lib.sh"

apply_template() {
  local template_path="$1"
  [[ -f "${template_path}" ]] || die "Missing manifest template: ${template_path}"

  # Keep this dependency-free: replace well-known placeholders with sed.
  # Use a delimiter that is unlikely to appear in values.
  sed \
    -e "s|__NAMESPACE__|${NAMESPACE}|g" \
    -e "s|__IMAGE_VERSION_REDISINSIGHT__|${IMAGE_VERSION_REDISINSIGHT}|g" \
    -e "s|__HOST__|${HOST}|g" \
    -e "s|__REDIS_HOST__|${REDIS_HOST}|g" \
    -e "s|__REDIS_PORT__|${REDIS_PORT}|g" \
    -e "s|__REDIS_ALIAS__|${REDIS_ALIAS}|g" \
    -e "s|__MIDDLEWARE_REF__|${MIDDLEWARE_REF}|g" \
    "${template_path}" | k apply -f -
}

usage() {
  cat << 'EOF'
Install RedisInsight on the cluster using Helm (Redis GUI).

Usage:
  netcup-kube-install redisinsight [--namespace platform] [--host redis.example.com] [--with-redis] [--uninstall]

Options:
  --namespace <name>   Namespace to install into (default: platform).
  --host <fqdn>        Create a Traefik Ingress for this host (entrypoint: web).
  --auth               Protect the UI with Traefik BasicAuth when --host is used (default: true).
  --no-auth            Disable BasicAuth even when --host is used (NOT recommended).
  --auth-user <user>   BasicAuth username (default: admin).
  --auth-pass <pass>   BasicAuth password (default: auto-generated and printed once).
  --with-redis         Install Redis in the same namespace first (via the existing `redis` recipe) if missing.
  --redis-storage <s>  Redis PVC size (default: recipes.conf DEFAULT_STORAGE_REDIS).
  --redis-password <p> Redis password (default: auto-generated by the Redis recipe).
  --uninstall          Uninstall RedisInsight resources from the namespace (deployment/service/ingress/secrets).
  --delete-pvc         When used with --uninstall, also delete the PVC (redisinsight-pvc). Default: keep PVC.
  -h, --help           Show this help.

Environment:
  KUBECONFIG           Kubeconfig to use. If not set, defaults to /etc/rancher/k3s/k3s.yaml (on the node).

Notes:
  - This installs RedisInsight from the official Helm chart.
  - RedisInsight provides a web GUI to manage Redis instances.
  - If you pass --host, the domain will be auto-added to Caddy edge-http domains (if on server).
  - You can connect to Redis instances in the cluster via their service names.
  - If you pass --with-redis, RedisInsight will be preconfigured to connect to the in-cluster service:
    redis-master.<namespace>.svc.cluster.local:6379
EOF
}

NAMESPACE="${NAMESPACE:-${NAMESPACE_PLATFORM}}"
HOST=""
WITH_REDIS="false"
REDIS_STORAGE="${DEFAULT_STORAGE_REDIS}"
REDIS_PASSWORD=""
REDIS_HOST=""
REDIS_PORT="6379"
REDIS_ALIAS=""
ENABLE_AUTH="auto" # auto|true|false
AUTH_USER="admin"
AUTH_PASS=""
AUTH_PASS_GENERATED="false"
MIDDLEWARE_REF=""
UNINSTALL="false"
DELETE_PVC="false"

generate_htpasswd_line() {
  local user="$1"
  local pass="$2"

  if command -v htpasswd > /dev/null 2>&1; then
    # bcrypt (preferred, required)
    htpasswd -nbB "${user}" "${pass}" | tr -d '\n'
    return 0
  fi

  # No supported strong password hashing tool available
  return 1
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --namespace)
      shift
      NAMESPACE="${1:-}"
      ;;
    --namespace=*)
      NAMESPACE="${1#*=}"
      ;;
    --host)
      shift
      HOST="${1:-}"
      ;;
    --host=*)
      HOST="${1#*=}"
      ;;
    --with-redis)
      WITH_REDIS="true"
      ;;
    --redis-storage)
      shift
      REDIS_STORAGE="${1:-}"
      ;;
    --redis-storage=*)
      REDIS_STORAGE="${1#*=}"
      ;;
    --redis-password)
      shift
      REDIS_PASSWORD="${1:-}"
      ;;
    --redis-password=*)
      REDIS_PASSWORD="${1#*=}"
      ;;
    --auth)
      ENABLE_AUTH="true"
      ;;
    --no-auth)
      ENABLE_AUTH="false"
      ;;
    --auth-user)
      shift
      AUTH_USER="${1:-}"
      ;;
    --auth-user=*)
      AUTH_USER="${1#*=}"
      ;;
    --auth-pass)
      shift
      AUTH_PASS="${1:-}"
      ;;
    --auth-pass=*)
      AUTH_PASS="${1#*=}"
      ;;
    --uninstall)
      UNINSTALL="true"
      ;;
    --delete-pvc)
      DELETE_PVC="true"
      ;;
    -h | --help | help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
  shift || true
done

[[ -n "${NAMESPACE}" ]] || die "Namespace is required"

REDIS_HOST="redis-master.${NAMESPACE}.svc.cluster.local"
REDIS_ALIAS="redis-${NAMESPACE}"

log "Installing RedisInsight into namespace: ${NAMESPACE}"

# Ensure namespace exists
recipe_ensure_namespace "${NAMESPACE}"

if [[ "${UNINSTALL}" == "true" ]]; then
  if [[ "${DELETE_PVC}" == "true" ]]; then
    recipe_confirm_or_die "Uninstall RedisInsight from namespace ${NAMESPACE} (will delete deployment/service/ingress and PVC redisinsight-pvc)"
  else
    recipe_confirm_or_die "Uninstall RedisInsight from namespace ${NAMESPACE} (will delete deployment/service/ingress; PVC redisinsight-pvc will be kept)"
  fi
  recipe_kdelete ingress redisinsight -n "${NAMESPACE}"
  recipe_kdelete middleware redisinsight-auth -n "${NAMESPACE}"
  recipe_kdelete secret redisinsight-basicauth -n "${NAMESPACE}"
  recipe_kdelete secret redisinsight-encryption -n "${NAMESPACE}"
  recipe_kdelete service redisinsight -n "${NAMESPACE}"
  recipe_kdelete deployment redisinsight -n "${NAMESPACE}"
  if [[ "${DELETE_PVC}" == "true" ]]; then
    recipe_kdelete pvc redisinsight-pvc -n "${NAMESPACE}"
  else
    log "Keeping PVC redisinsight-pvc (use --delete-pvc to remove it)."
  fi
  log "RedisInsight uninstall requested."
  exit 0
fi

# If exposed via host, protect the UI by default.
if [[ -n "${HOST}" ]]; then
  if [[ "${ENABLE_AUTH}" == "auto" ]]; then
    ENABLE_AUTH="true"
  fi
  if [[ "${ENABLE_AUTH}" == "true" ]]; then
    [[ -n "${AUTH_USER}" ]] || die "--auth-user is required when auth is enabled"

    if [[ -z "${AUTH_PASS}" ]]; then
      if command -v openssl > /dev/null 2>&1; then
        AUTH_PASS="$(openssl rand -base64 18 | tr -d '\n')"
      else
        die "openssl not found; pass --auth-pass explicitly"
      fi
      AUTH_PASS_GENERATED="true"
      log "Generated RedisInsight BasicAuth password (store this now):"
      echo "  user: ${AUTH_USER}"
      echo "  pass: ${AUTH_PASS}"
    fi

    htline="$(generate_htpasswd_line "${AUTH_USER}" "${AUTH_PASS}")" || die "Could not generate htpasswd line (need htpasswd or openssl)"
    # Create/Update the secret Traefik expects.
    k -n "${NAMESPACE}" create secret generic redisinsight-basicauth \
      --from-literal=users="${htline}" \
      --dry-run=client -o yaml | k apply -f -

    # Ensure middleware exists.
    MIDDLEWARE_REF="${NAMESPACE}-redisinsight-auth@kubernetescrd"
    apply_template "${SCRIPT_DIR}/middleware-basicauth.yaml"
  else
    MIDDLEWARE_REF=""
  fi
fi

# Ensure RedisInsight has a stable encryption key for storing sensitive data (DB passwords) in /data.
#
# Without this, some environments fail to initialize keychain-based encryption (keytar/libsecret),
# which can prevent storing configured connections.
if ! k -n "${NAMESPACE}" get secret redisinsight-encryption > /dev/null 2>&1; then
  log "Creating RedisInsight encryption secret (redisinsight-encryption)"
  enc_key="$(head -c 32 /dev/urandom | base64 | tr -d '\n')"
  k -n "${NAMESPACE}" create secret generic redisinsight-encryption --from-literal=encryption-key="${enc_key}"
else
  log "RedisInsight encryption secret already present (redisinsight-encryption)."
fi

# Optional: ensure Redis exists first (so RedisInsight has something to connect to out-of-the-box).
if [[ "${WITH_REDIS}" == "true" ]]; then
  if k -n "${NAMESPACE}" get svc redis-master > /dev/null 2>&1; then
    log "Redis already present (svc/redis-master). Skipping Redis install."
  else
    log "Redis not found (svc/redis-master). Installing Redis first (Bitnami chart) via redis recipe."
    redis_installer="${SCRIPTS_DIR}/recipes/redis/install.sh"
    [[ -x "${redis_installer}" ]] || chmod +x "${redis_installer}"
    redis_args=(--namespace "${NAMESPACE}")
    if [[ -n "${REDIS_STORAGE}" ]]; then
      redis_args+=(--storage "${REDIS_STORAGE}")
    fi
    if [[ -n "${REDIS_PASSWORD}" ]]; then
      redis_args+=(--password "${REDIS_PASSWORD}")
    fi
    "${redis_installer}" "${redis_args[@]}"
  fi
fi

# Deploy RedisInsight using manifests
log "Deploying RedisInsight"
apply_template "${SCRIPT_DIR}/pvc.yaml"
if [[ "${WITH_REDIS}" == "true" ]]; then
  apply_template "${SCRIPT_DIR}/deployment.with-redis.yaml"
else
  apply_template "${SCRIPT_DIR}/deployment.yaml"
fi
apply_template "${SCRIPT_DIR}/service.yaml"

log "Waiting for RedisInsight to be ready"
k wait --for=condition=available --timeout=300s deployment/redisinsight -n "${NAMESPACE}"

log "RedisInsight installed successfully!"
echo

seed_redisinsight_connection() {
  local host="$1"
  local port="$2"
  local name="$3"
  local username="$4"

  command -v curl > /dev/null 2>&1 || {
    log "WARN: curl not found; cannot auto-seed RedisInsight connection."
    return 0
  }

  local password
  password="$(k -n "${NAMESPACE}" get secret redis -o jsonpath='{.data.redis-password}' | base64 -d 2> /dev/null || true)"
  [[ -n "${password}" ]] || {
    log "WARN: could not read Redis password from Secret/redis; cannot auto-seed RedisInsight connection."
    return 0
  }

  # Use a short-lived port-forward so we can call the RedisInsight API.
  # The service exposes port 80 -> container 5540.
  local pf_port="18001"
  local pf_log="/tmp/netcup-kube-redisinsight-portforward.$$.log"
  local pf_pid=""

  k -n "${NAMESPACE}" port-forward svc/redisinsight "${pf_port}:80" > "${pf_log}" 2>&1 &
  pf_pid="$!"
  trap 'kill "${pf_pid}" 2>/dev/null || true; wait "${pf_pid}" 2>/dev/null || true; rm -f "${pf_log}"' RETURN

  # Wait for port-forward to be ready
  for _ in {1..30}; do
    if curl -fsS "http://127.0.0.1:${pf_port}/api/databases" > /dev/null 2>&1; then
      break
    fi
    sleep 0.2
  done

  # If the DB already exists, do nothing.
  if curl -fsS "http://127.0.0.1:${pf_port}/api/databases" | grep -q "\"name\":\"${name}\""; then
    log "RedisInsight already has database '${name}'."
    return 0
  fi

  log "Seeding RedisInsight connection '${name}' -> ${host}:${port}"
  curl -fsS -X POST "http://127.0.0.1:${pf_port}/api/databases" \
    -H 'Content-Type: application/json' \
    -d "{\"name\":\"${name}\",\"host\":\"${host}\",\"port\":${port},\"username\":\"${username}\",\"password\":\"${password}\"}" \
    > /dev/null
}

if [[ "${WITH_REDIS}" == "true" ]]; then
  # Make Redis show up by default inside RedisInsight.
  # Some RedisInsight versions do not reliably auto-add DBs from RI_REDIS_* env vars in Kubernetes,
  # so we seed the connection via the local API once.
  seed_redisinsight_connection "${REDIS_HOST}" "${REDIS_PORT}" "${REDIS_ALIAS}" "default" || true
fi

if [[ -n "${HOST}" ]]; then
  log "Creating/Updating Traefik ingress for ${HOST}"
  # If auth is enabled, patch the ingress annotation after apply (avoid complex YAML templating).
  apply_template "${SCRIPT_DIR}/ingress.yaml"
  if [[ "${ENABLE_AUTH}" == "true" ]]; then
    k -n "${NAMESPACE}" annotate ingress redisinsight \
      traefik.ingress.kubernetes.io/router.middlewares="${MIDDLEWARE_REF}" \
      --overwrite
  fi

  recipe_maybe_add_edge_http_domain "${HOST}"
fi

echo
echo "RedisInsight UI:"
if [[ -n "${HOST}" ]]; then
  echo "  URL: https://${HOST}/"
  if [[ "${ENABLE_AUTH}" == "true" ]]; then
    echo
    echo "BasicAuth:"
    echo "  user: ${AUTH_USER}"
    if [[ "${AUTH_PASS_GENERATED}" == "true" ]]; then
      echo "  pass: ${AUTH_PASS}"
    else
      echo "  pass: (not retrievable from cluster; Secret stores an htpasswd hash)"
    fi
    echo
    echo "Inspect the htpasswd hash stored in the secret:"
    echo "  kubectl -n ${NAMESPACE} get secret redisinsight-basicauth -o jsonpath='{.data.users}' | base64 -d"
    echo
    echo "Reset BasicAuth credentials:"
    echo "  kubectl -n ${NAMESPACE} delete secret redisinsight-basicauth"
    echo "  # then re-run installer (it will generate a new password unless you pass --auth-pass)"
  fi
else
  echo "  Port-forward: kubectl port-forward -n ${NAMESPACE} svc/redisinsight 8001:80"
  echo "  Then open: http://localhost:8001"
fi
echo
echo "To connect to Redis instances in the cluster:"
echo "  - Host: redis-master.${NAMESPACE}.svc.cluster.local (or your Redis service name)"
echo "  - Port: 6379"
echo "  - Auth: Get password from: kubectl get secret -n ${NAMESPACE} redis -o jsonpath='{.data.redis-password}' | base64 -d"
