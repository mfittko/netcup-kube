#!/usr/bin/env bash
set -euo pipefail

# netcup-kube remote bootstrap helper
# - Sets up SSH key access via root@<host> (password from Netcup)
# - Installs sudo + git on the server (apt)
# - Creates a sudo-enabled user and configures authorized_keys
# - Clones this repo and runs the bootstrap as that user (sudo)
#
# Requirements (local): ssh, ssh-copy-id, scp. Optional: sshpass for non-interactive password entry.
#
# Usage examples:
#   bin/netcup-kube-remote root.example.com                   # prompts silently for root password (if sshpass installed), user=cubeadmin
#   bin/netcup-kube-remote 203.0.113.10 --user ops            # prompts silently
#   export ROOT_PASS; read -r -s ROOT_PASS; ./bin/netcup-kube-remote host --user ops  # or pre-set env var
#   bin/netcup-kube-remote host --user ops --pubkey ~/.ssh/id_ed25519.pub
#   # Run a netcup-kube command on the remote host (forces a TTY so prompts work)
#   bin/netcup-kube-remote host --user ops run bootstrap
#   bin/netcup-kube-remote host --user ops run pair
#   bin/netcup-kube-remote host --user ops run dns
#   bin/netcup-kube-remote host --user ops run dns --type edge-http --domains "kube.example.com|demo.example.com"
#
# After bootstrap you can SSH as the new user: ssh <user>@<host>

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR%/bin}"
DEFAULT_CONFIG="${PROJECT_ROOT}/config/netcup-kube.env"
LOCAL_CMD="$(basename "$0")"

usage() {
  local exit_code="${1:-0}"
  cat >&2 << 'EOF'
Usage:
  netcup-kube-remote [<host-or-ip>] [--user <name>] [--pubkey <path>] [--repo <url>] [--config <path>] <command> [command options]

Commands:
  provision   Prepare the target host (sudo user + repo clone/update). Does not run netcup-kube.
  git         Remote git control for the repo (checkout/pull branch/ref).
  domains     Print currently configured edge-http domains (comma-separated).
  run         Run a netcup-kube command on the target host (forces TTY by default).

Common host selection:
  - If <host-or-ip> is omitted, defaults to MGMT_HOST/MGMT_IP from ./config/netcup-kube.env (if present).

Examples:
  netcup-kube-remote provision
  netcup-kube-remote mfittko.com --user ops provision
  netcup-kube-remote git --branch main --pull
  netcup-kube-remote domains
  netcup-kube-remote run bootstrap
  netcup-kube-remote run --env-file ./env/bootstrap.env bootstrap
  netcup-kube-remote run --branch main --pull bootstrap

Command options:
  git [--branch <name>] [--ref <ref>] [--pull|--no-pull]
  run [--no-tty] [--env-file <path>] [--branch <name>] [--ref <ref>] [--pull|--no-pull] [--] <netcup-kube args...>

Notes:
  - `run` uses SSH with a forced TTY (unless --no-tty) so prompts can read from /dev/tty.
  - `--env-file` is copied to the remote host and bash-sourced before running netcup-kube.
EOF
  exit "${exit_code}"
}

usage_run() {
  local exit_code="${1:-0}"
  cat >&2 << 'EOF'
Usage:
  netcup-kube-remote [<host-or-ip>] [--user <name>] run [--no-tty] [--env-file <path>] [--branch <name>] [--ref <ref>] [--pull|--no-pull] [--] <netcup-kube args...>

Examples:
  netcup-kube-remote run bootstrap
  netcup-kube-remote run pair
  netcup-kube-remote run dns
  netcup-kube-remote run dns --type edge-http --domains "kube.example.com|demo.example.com"
  netcup-kube-remote run --env-file ./config/netcup-kube.env bootstrap

Notes:
  - Pass -- to stop parsing netcup-kube-remote flags, e.g.: netcup-kube-remote run -- --help
EOF
  exit "${exit_code}"
}

HOST=""
if [[ $# -gt 0 && "${1:-}" != -* && "${1:-}" != "run" && "${1:-}" != "git" ]]; then
  HOST="$1"
  shift || true
fi

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || "${1:-}" == "help" ]]; then
  usage 0
fi

NEW_USER="cubeadmin"
PUBKEY_PATH=""
REPO_URL="https://github.com/mfittko/netcup-kube.git"
CONFIG_PATH="${DEFAULT_CONFIG}"
DO_RUN=false
DO_GIT=false
DO_PROVISION=false
DO_DOMAINS=false
FORCE_TTY=true
RUN_ENV_FILE=""
RUN_ARGS=()
GIT_BRANCH=""
GIT_REF=""
GIT_PULL=false
GIT_PULL_SET=false

# Parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help | help)
      usage 0
      ;;
    --user)
      NEW_USER="${2:-}"
      shift 2 || true
      ;;
    --pubkey)
      PUBKEY_PATH="${2:-}"
      shift 2 || true
      ;;
    --repo)
      REPO_URL="${2:-}"
      shift 2 || true
      ;;
    --config)
      CONFIG_PATH="${2:-}"
      shift 2 || true
      ;;
    provision)
      DO_PROVISION=true
      shift || true
      break
      ;;
    domains)
      DO_DOMAINS=true
      shift || true
      break
      ;;
    run)
      DO_RUN=true
      shift || true
      # Parse run-specific flags
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --no-tty)
            FORCE_TTY=false
            shift || true
            ;;
          --env-file)
            RUN_ENV_FILE="${2:-}"
            shift 2 || true
            ;;
          --branch)
            GIT_BRANCH="${2:-}"
            # If the user asked for a branch but did not specify pull behavior, default to pulling.
            if [[ "${GIT_PULL_SET}" != "true" ]]; then
              GIT_PULL=true
            fi
            shift 2 || true
            ;;
          --ref)
            GIT_REF="${2:-}"
            shift 2 || true
            ;;
          --no-pull)
            GIT_PULL=false
            GIT_PULL_SET=true
            shift || true
            ;;
          --pull)
            GIT_PULL=true
            GIT_PULL_SET=true
            shift || true
            ;;
          --)
            shift || true
            break
            ;;
          -*)
            echo "Unknown flag for run: $1" >&2
            exit 1
            ;;
          *)
            break
            ;;
        esac
      done
      RUN_ARGS=("$@")
      break
      ;;
    git)
      DO_GIT=true
      # For the standalone `git` subcommand, default to pulling unless the user disables it.
      GIT_PULL=true
      GIT_PULL_SET=true
      shift || true
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --branch)
            GIT_BRANCH="${2:-}"
            shift 2 || true
            ;;
          --ref)
            GIT_REF="${2:-}"
            shift 2 || true
            ;;
          --no-pull)
            GIT_PULL=false
            GIT_PULL_SET=true
            shift || true
            ;;
          --pull)
            GIT_PULL=true
            GIT_PULL_SET=true
            shift || true
            ;;
          --)
            shift || true
            break
            ;;
          -*)
            echo "Unknown flag for git: $1" >&2
            exit 1
            ;;
          *)
            break
            ;;
        esac
      done
      # No positional args expected for git; ignore any extras.
      break
      ;;
    *)
      echo "Unknown flag: $1" >&2
      usage 1
      ;;
  esac
done

if [[ "${DO_RUN}" == "true" && "${#RUN_ARGS[@]}" -lt 1 ]]; then
  usage_run 1
fi

if [[ "${DO_PROVISION}" != "true" && "${DO_GIT}" != "true" && "${DO_RUN}" != "true" && "${DO_DOMAINS}" != "true" ]]; then
  usage 1
fi

if [[ -z "$HOST" ]]; then
  if [[ -n "${CONFIG_PATH}" && -f "${CONFIG_PATH}" ]]; then
    # shellcheck disable=SC1090
    source "${CONFIG_PATH}"
    HOST="${MGMT_HOST:-${MGMT_IP:-}}"
    # If no --user was provided, prefer the configs MGMT_USER/DEFAULT_USER as the remote sudo user.
    if [[ "${NEW_USER}" == "cubeadmin" ]]; then
      NEW_USER="${MGMT_USER:-${DEFAULT_USER:-${NEW_USER}}}"
    fi
  fi
fi

[[ -n "${HOST}" ]] || {
  echo "No host provided and no MGMT_HOST/MGMT_IP found in ${CONFIG_PATH}." >&2
  usage 1
}

# Pick a public key (prefer ed25519)
default_pubkey=""
for cand in "$PUBKEY_PATH" "$HOME/.ssh/id_ed25519.pub" "$HOME/.ssh/id_rsa.pub"; do
  if [[ -n "$cand" && -f "$cand" ]]; then
    default_pubkey="$cand"
    break
  fi
done
if [[ -z "$default_pubkey" ]]; then
  echo "No public key found. Generate one, e.g.: ssh-keygen -t ed25519 -C '$(whoami)@$(hostname)'" >&2
  exit 1
fi
PUBKEY_PATH="$default_pubkey"
PUBKEY_CONTENT="$(cat "$PUBKEY_PATH")"

ssh_root() { ssh -o StrictHostKeyChecking=no root@"$HOST" "$@"; }
ssh_user() { ssh -o StrictHostKeyChecking=no "${NEW_USER}@${HOST}" "$@"; }
scp_user() { scp -o StrictHostKeyChecking=no "$@"; }

remote_repo_dir() { echo "/home/${NEW_USER}/netcup-kube"; }
remote_bin_path() { echo "$(remote_repo_dir)/bin/netcup-kube"; }

remote_git_sync() {
  local repo
  repo="$(remote_repo_dir)"
  local branch="${GIT_BRANCH}"
  local ref="${GIT_REF}"
  local pull="${GIT_PULL}"

  # shellcheck disable=SC2016
  # NOTE: ssh executes a remote shell and does not preserve empty arguments reliably.
  # Use explicit placeholders to keep positional args stable.
  local branch_arg="${branch:-__NONE__}"
  local ref_arg="${ref:-__NONE__}"
  ssh_user "bash -s" -- "${repo}" "${branch_arg}" "${ref_arg}" "${pull}" << 'EOS'
set -euo pipefail
repo="${1:?repo dir required}"
branch="${2:-__NONE__}"
ref="${3:-__NONE__}"
pull="${4:-true}"

[[ "${branch}" == "__NONE__" ]] && branch=""
[[ "${ref}" == "__NONE__" ]] && ref=""

cd "${repo}"
git fetch --all -p

if [[ -n "${ref}" ]]; then
  echo "[remote] checkout ref: ${ref}"
  git checkout --detach "${ref}"
elif [[ -n "${branch}" ]]; then
  echo "[remote] checkout branch: ${branch}"
  if git show-ref --verify --quiet "refs/heads/${branch}"; then
    git checkout "${branch}"
  else
    if ! git show-ref --verify --quiet "refs/remotes/origin/${branch}"; then
      echo "[remote] ERROR: origin/${branch} not found" >&2
      exit 1
    fi
    git checkout -b "${branch}" --track "origin/${branch}"
  fi
fi

if [[ -n "${branch}" && -z "${ref}" ]]; then
  # Make sure the branch tracks the correct remote branch, to avoid stale merge config
  # (e.g. tracking a deleted branch).
  git branch --set-upstream-to="origin/${branch}" "${branch}" >/dev/null 2>&1 || true
fi

if [[ "${pull}" == "true" && -z "${ref}" ]]; then
  if [[ -n "${branch}" ]]; then
    echo "[remote] pull: origin ${branch} (ff-only)"
    git pull --ff-only origin "${branch}"
  else
    # No explicit branch requested; keep behavior safe/explicit.
    echo "[remote] NOTE: --pull requested but no --branch/--ref provided; skipping pull." >&2
  fi
fi
EOS
}

ensure_root_access_or_die() {
  # Ensure our key is on root via ssh-copy-id (password auth)
  if ssh -o BatchMode=yes -o StrictHostKeyChecking=no root@"$HOST" true 2> /dev/null; then
    echo "SSH key already works for root@${HOST}"
    return 0
  fi

  if command -v sshpass > /dev/null 2>&1; then
    if [[ -z "${ROOT_PASS:-}" ]]; then
      read -r -s -p "Root password for root@${HOST}: " ROOT_PASS
      echo
    fi
    echo "Pushing SSH key to root@${HOST} with sshpass+ssh-copy-id"
    sshpass -p "$ROOT_PASS" ssh-copy-id -o StrictHostKeyChecking=no -f -i "$PUBKEY_PATH" root@"$HOST"
    unset ROOT_PASS || true
    return 0
  fi

  echo "Passwordless SSH for root not set up yet." >&2
  echo "Install sshpass to allow a silent prompt here, or run:" >&2
  echo "  ssh-copy-id -o StrictHostKeyChecking=no -i '$PUBKEY_PATH' root@${HOST}" >&2
  echo "Then re-run: ${LOCAL_CMD} ${HOST} provision" >&2
  exit 1
}

ensure_user_access_or_die() {
  # Do NOT touch root for run/git. Require that provisioning already happened.
  if ssh -o BatchMode=yes -o StrictHostKeyChecking=no "${NEW_USER}@${HOST}" true 2> /dev/null; then
    return 0
  fi

  echo "SSH key does not work for ${NEW_USER}@${HOST}." >&2
  echo "Run provisioning first (uses root once):" >&2
  echo "  ${LOCAL_CMD} ${HOST} --user ${NEW_USER} provision" >&2
  exit 1
}

ensure_remote_repo_or_die() {
  local repo
  repo="$(remote_repo_dir)"
  if ssh -o BatchMode=yes -o StrictHostKeyChecking=no "${NEW_USER}@${HOST}" "test -d '${repo}'" 2> /dev/null; then
    return 0
  fi

  echo "Remote repo not found at ${NEW_USER}@${HOST}:${repo}" >&2
  echo "Run provisioning first:" >&2
  echo "  ${LOCAL_CMD} ${HOST} --user ${NEW_USER} provision" >&2
  exit 1
}

run_provision() {
  ensure_root_access_or_die

  REMOTE_SCRIPT="$(
    cat << 'EOS'
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update -y
apt-get install -y --no-install-recommends sudo git curl ca-certificates

# Create user if missing
if ! id -u __NEW_USER__ >/dev/null 2>&1; then
  adduser --disabled-password --gecos "" __NEW_USER__
fi
usermod -aG sudo __NEW_USER__
install -d -m 0700 -o __NEW_USER__ -g __NEW_USER__ /home/__NEW_USER__/.ssh
# Append key once
awk 'BEGIN{seen=0} $0=="__PUBKEY__"{seen=1} END{exit !seen}' /home/__NEW_USER__/.ssh/authorized_keys 2>/dev/null || \
  echo "__PUBKEY__" >> /home/__NEW_USER__/.ssh/authorized_keys
chown __NEW_USER__:__NEW_USER__ /home/__NEW_USER__/.ssh/authorized_keys
chmod 0600 /home/__NEW_USER__/.ssh/authorized_keys

# Passwordless sudo for the new user (limited to ALL here; adjust if desired)
cat >/etc/sudoers.d/90-__NEW_USER__ <<EOF
__NEW_USER__ ALL=(ALL) NOPASSWD:ALL
EOF
chmod 0440 /etc/sudoers.d/90-__NEW_USER__

# Clone or update netcup-kube
if [[ ! -d /home/__NEW_USER__/netcup-kube ]]; then
  sudo -u __NEW_USER__ git clone __REPO_URL__ /home/__NEW_USER__/netcup-kube
else
  # Only fetch here; pulling can fail if the repo is on a local branch that tracks a deleted remote branch.
  # Use the local wrappers `git` subcommand (or `run --branch/--ref`) to select a branch/ref and pull.
  cd /home/__NEW_USER__/netcup-kube && sudo -u __NEW_USER__ git fetch --all -p
fi

# Print how to continue
cat <<EOM
[remote] Provisioning complete.
Now run on your local machine (recommended):
  __LOCAL_CMD__ __HOST__ --user __NEW_USER__ run bootstrap

Or SSH into the server:
  ssh __NEW_USER__@__HOST__
Then on the server:
  sudo /home/__NEW_USER__/netcup-kube/bin/netcup-kube bootstrap
EOM
EOS
  )"

  # Substitute placeholders safely
  REMOTE_SCRIPT="${REMOTE_SCRIPT//__NEW_USER__/$NEW_USER}"
  REMOTE_SCRIPT="${REMOTE_SCRIPT//__PUBKEY__/$PUBKEY_CONTENT}"
  REMOTE_SCRIPT="${REMOTE_SCRIPT//__REPO_URL__/$REPO_URL}"
  REMOTE_SCRIPT="${REMOTE_SCRIPT//__HOST__/$HOST}"
  REMOTE_SCRIPT="${REMOTE_SCRIPT//__LOCAL_CMD__/$LOCAL_CMD}"

  ssh_root "bash -s" <<< "$REMOTE_SCRIPT"
}

if [[ "${DO_PROVISION}" == "true" ]]; then
  run_provision
  exit 0
fi

if [[ "${DO_GIT}" == "true" || "${DO_RUN}" == "true" || "${DO_DOMAINS}" == "true" ]]; then
  ensure_user_access_or_die
  ensure_remote_repo_or_die
fi

if [[ "${DO_GIT}" == "true" ]]; then
  remote_git_sync
fi

if [[ "${DO_DOMAINS}" == "true" ]]; then
  remote_bin="$(remote_bin_path)"
  # Print comma-separated edge-http domains from the current Caddyfile (if in http01 mode).
  # If not in edge-http mode, exit non-zero with a message.
  ssh_user "sudo -E ${remote_bin} dns --show --type edge-http --format csv"
  exit 0
fi

if [[ "${DO_RUN}" == "true" ]]; then
  if [[ "${#RUN_ARGS[@]}" -lt 1 ]]; then
    echo "Missing netcup-kube arguments. Example: $(basename "$0") ${HOST} --user ${NEW_USER} run bootstrap" >&2
    exit 1
  fi

  case "${RUN_ARGS[0]}" in
    bootstrap | join | pair | dns | help | -h | --help) ;;
    *)
      echo "Unsupported netcup-kube command for remote run: ${RUN_ARGS[0]}" >&2
      echo "Supported: bootstrap|join|pair|dns|help" >&2
      exit 1
      ;;
  esac

  if [[ -n "${RUN_ENV_FILE}" && ! -f "${RUN_ENV_FILE}" ]]; then
    echo "--env-file not found: ${RUN_ENV_FILE}" >&2
    exit 1
  fi

  if [[ -n "${GIT_BRANCH}" || -n "${GIT_REF}" || "${GIT_PULL}" == "true" ]]; then
    remote_git_sync
  fi

  remote_bin="$(remote_bin_path)"
  # Force a TTY so remote prompts can read from /dev/tty.
  tty_flags=()
  if [[ "${FORCE_TTY}" == "true" ]]; then
    tty_flags=(-tt)
  fi

  # ssh does not preserve empty args reliably; use a placeholder.
  remote_env="__NONE__"
  if [[ -n "${RUN_ENV_FILE}" ]]; then
    remote_env="/tmp/netcup-kube-remote.env.$$"
    echo "[local] Uploading env file to ${NEW_USER}@${HOST}:${remote_env}"
    scp_user "${RUN_ENV_FILE}" "${NEW_USER}@${HOST}:${remote_env}"
  fi

  # ssh joins argv into a single remote shell string; shell-escape args to avoid interpretation (e.g. pipes in --domains).
  #
  # IMPORTANT: do not stream a script over stdin here, because with a forced TTY the pty will echo
  # the script contents and stdin may end up exhausted for follow-up prompts. Use `bash -lc` so
  # netcup-kube inherits an interactive TTY cleanly.
  # shellcheck disable=SC2016
  remote_runner='
set -euo pipefail
env_file="${1:-}"
bin="${2:-}"
shift 2 || true

if [[ "${env_file}" != "__NONE__" && -n "${env_file}" ]]; then
  set -a
  # shellcheck disable=SC1090
  source "${env_file}"
  set +a
fi

exec "${bin}" "$@"
'
  remote_cmd=(sudo -E bash -lc "${remote_runner}" bash "${remote_env}" "${remote_bin}" "${RUN_ARGS[@]}")
  remote_cmd_q=""
  printf -v remote_cmd_q '%q ' "${remote_cmd[@]}"
  remote_cmd_q="${remote_cmd_q% }"

  echo "[local] Running on ${NEW_USER}@${HOST}: ${remote_cmd_q}"
  ssh_user "${tty_flags[@]}" "${remote_cmd_q}"

  if [[ "${remote_env}" != "__NONE__" ]]; then
    ssh_user "${tty_flags[@]}" "sudo rm -f '${remote_env}'" || true
  fi
fi
